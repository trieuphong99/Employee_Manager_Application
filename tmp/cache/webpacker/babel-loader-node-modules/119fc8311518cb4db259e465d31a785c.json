{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar IsInteger = require('./IsInteger');\n\nvar Type = require('./Type');\n\nvar MAX_SAFE_INTEGER = require('../helpers/maxSafeInteger');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar $charCodeAt = require('../helpers/callBound')('String.prototype.charCodeAt'); // https://ecma-international.org/ecma-262/6.0/#sec-advancestringindex\n\n\nmodule.exports = function AdvanceStringIndex(S, index, unicode) {\n  if (Type(S) !== 'String') {\n    throw new $TypeError('Assertion failed: `S` must be a String');\n  }\n\n  if (!IsInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {\n    throw new $TypeError('Assertion failed: `length` must be an integer >= 0 and <= 2**53');\n  }\n\n  if (Type(unicode) !== 'Boolean') {\n    throw new $TypeError('Assertion failed: `unicode` must be a Boolean');\n  }\n\n  if (!unicode) {\n    return index + 1;\n  }\n\n  var length = S.length;\n\n  if (index + 1 >= length) {\n    return index + 1;\n  }\n\n  var first = $charCodeAt(S, index);\n\n  if (first < 0xD800 || first > 0xDBFF) {\n    return index + 1;\n  }\n\n  var second = $charCodeAt(S, index + 1);\n\n  if (second < 0xDC00 || second > 0xDFFF) {\n    return index + 1;\n  }\n\n  return index + 2;\n};","map":null,"metadata":{},"sourceType":"module"}