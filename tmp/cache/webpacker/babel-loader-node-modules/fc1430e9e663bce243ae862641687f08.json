{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar DefineOwnProperty = require('../helpers/DefineOwnProperty');\n\nvar isPropertyDescriptor = require('../helpers/isPropertyDescriptor');\n\nvar isSamePropertyDescriptor = require('../helpers/isSamePropertyDescriptor');\n\nvar FromPropertyDescriptor = require('./FromPropertyDescriptor');\n\nvar IsAccessorDescriptor = require('./IsAccessorDescriptor');\n\nvar IsDataDescriptor = require('./IsDataDescriptor');\n\nvar IsGenericDescriptor = require('./IsGenericDescriptor');\n\nvar IsPropertyKey = require('./IsPropertyKey');\n\nvar SameValue = require('./SameValue');\n\nvar Type = require('./Type'); // https://www.ecma-international.org/ecma-262/6.0/#sec-validateandapplypropertydescriptor\n// https://www.ecma-international.org/ecma-262/8.0/#sec-validateandapplypropertydescriptor\n// eslint-disable-next-line max-lines-per-function, max-statements, max-params\n\n\nmodule.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {\n  // this uses the ES2017+ logic, since it fixes a number of bugs in the ES2015 logic.\n  var oType = Type(O);\n\n  if (oType !== 'Undefined' && oType !== 'Object') {\n    throw new $TypeError('Assertion failed: O must be undefined or an Object');\n  }\n\n  if (Type(extensible) !== 'Boolean') {\n    throw new $TypeError('Assertion failed: extensible must be a Boolean');\n  }\n\n  if (!isPropertyDescriptor({\n    Type: Type,\n    IsDataDescriptor: IsDataDescriptor,\n    IsAccessorDescriptor: IsAccessorDescriptor\n  }, Desc)) {\n    throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');\n  }\n\n  if (Type(current) !== 'Undefined' && !isPropertyDescriptor({\n    Type: Type,\n    IsDataDescriptor: IsDataDescriptor,\n    IsAccessorDescriptor: IsAccessorDescriptor\n  }, current)) {\n    throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');\n  }\n\n  if (oType !== 'Undefined' && !IsPropertyKey(P)) {\n    throw new $TypeError('Assertion failed: if O is not undefined, P must be a Property Key');\n  }\n\n  if (Type(current) === 'Undefined') {\n    if (!extensible) {\n      return false;\n    }\n\n    if (IsGenericDescriptor(Desc) || IsDataDescriptor(Desc)) {\n      if (oType !== 'Undefined') {\n        DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, {\n          '[[Configurable]]': Desc['[[Configurable]]'],\n          '[[Enumerable]]': Desc['[[Enumerable]]'],\n          '[[Value]]': Desc['[[Value]]'],\n          '[[Writable]]': Desc['[[Writable]]']\n        });\n      }\n    } else {\n      if (!IsAccessorDescriptor(Desc)) {\n        throw new $TypeError('Assertion failed: Desc is not an accessor descriptor');\n      }\n\n      if (oType !== 'Undefined') {\n        return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, Desc);\n      }\n    }\n\n    return true;\n  }\n\n  if (IsGenericDescriptor(Desc) && !('[[Configurable]]' in Desc) && !('[[Enumerable]]' in Desc)) {\n    return true;\n  }\n\n  if (isSamePropertyDescriptor({\n    SameValue: SameValue\n  }, Desc, current)) {\n    return true; // removed by ES2017, but should still be correct\n  } // \"if every field in Desc is absent, return true\" can't really match the assertion that it's a Property Descriptor\n\n\n  if (!current['[[Configurable]]']) {\n    if (Desc['[[Configurable]]']) {\n      return false;\n    }\n\n    if ('[[Enumerable]]' in Desc && !Desc['[[Enumerable]]'] === !!current['[[Enumerable]]']) {\n      return false;\n    }\n  }\n\n  if (IsGenericDescriptor(Desc)) {// no further validation is required.\n  } else if (IsDataDescriptor(current) !== IsDataDescriptor(Desc)) {\n    if (!current['[[Configurable]]']) {\n      return false;\n    }\n\n    if (IsDataDescriptor(current)) {\n      if (oType !== 'Undefined') {\n        DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, {\n          '[[Configurable]]': current['[[Configurable]]'],\n          '[[Enumerable]]': current['[[Enumerable]]'],\n          '[[Get]]': undefined\n        });\n      }\n    } else if (oType !== 'Undefined') {\n      DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, {\n        '[[Configurable]]': current['[[Configurable]]'],\n        '[[Enumerable]]': current['[[Enumerable]]'],\n        '[[Value]]': undefined\n      });\n    }\n  } else if (IsDataDescriptor(current) && IsDataDescriptor(Desc)) {\n    if (!current['[[Configurable]]'] && !current['[[Writable]]']) {\n      if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {\n        return false;\n      }\n\n      if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {\n        return false;\n      }\n\n      return true;\n    }\n  } else if (IsAccessorDescriptor(current) && IsAccessorDescriptor(Desc)) {\n    if (!current['[[Configurable]]']) {\n      if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {\n        return false;\n      }\n\n      if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {\n        return false;\n      }\n\n      return true;\n    }\n  } else {\n    throw new $TypeError('Assertion failed: current and Desc are not both data, both accessors, or one accessor and one data.');\n  }\n\n  if (oType !== 'Undefined') {\n    return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, Desc);\n  }\n\n  return true;\n};","map":null,"metadata":{},"sourceType":"module"}