{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar Call = require('./Call');\n\nvar GetMethod = require('./GetMethod');\n\nvar IsCallable = require('./IsCallable');\n\nvar Type = require('./Type'); // https://ecma-international.org/ecma-262/6.0/#sec-iteratorclose\n\n\nmodule.exports = function IteratorClose(iterator, completion) {\n  if (Type(iterator) !== 'Object') {\n    throw new $TypeError('Assertion failed: Type(iterator) is not Object');\n  }\n\n  if (!IsCallable(completion)) {\n    throw new $TypeError('Assertion failed: completion is not a thunk for a Completion Record');\n  }\n\n  var completionThunk = completion;\n  var iteratorReturn = GetMethod(iterator, 'return');\n\n  if (typeof iteratorReturn === 'undefined') {\n    return completionThunk();\n  }\n\n  var completionRecord;\n\n  try {\n    var innerResult = Call(iteratorReturn, iterator, []);\n  } catch (e) {\n    // if we hit here, then \"e\" is the innerResult completion that needs re-throwing\n    // if the completion is of type \"throw\", this will throw.\n    completionThunk();\n    completionThunk = null; // ensure it's not called twice.\n    // if not, then return the innerResult completion\n\n    throw e;\n  }\n\n  completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does\n\n  completionThunk = null; // ensure it's not called twice.\n\n  if (Type(innerResult) !== 'Object') {\n    throw new $TypeError('iterator .return must return an object');\n  }\n\n  return completionRecord;\n};","map":null,"metadata":{},"sourceType":"module"}