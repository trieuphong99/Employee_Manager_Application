{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $Number = GetIntrinsic('%Number%');\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar $isNaN = require('../helpers/isNaN');\n\nvar $isFinite = require('../helpers/isFinite');\n\nvar isPrefixOf = require('../helpers/isPrefixOf');\n\nvar ToNumber = require('./ToNumber');\n\nvar ToPrimitive = require('./ToPrimitive');\n\nvar Type = require('./Type'); // https://www.ecma-international.org/ecma-262/5.1/#sec-11.8.5\n// eslint-disable-next-line max-statements\n\n\nmodule.exports = function AbstractRelationalComparison(x, y, LeftFirst) {\n  if (Type(LeftFirst) !== 'Boolean') {\n    throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');\n  }\n\n  var px;\n  var py;\n\n  if (LeftFirst) {\n    px = ToPrimitive(x, $Number);\n    py = ToPrimitive(y, $Number);\n  } else {\n    py = ToPrimitive(y, $Number);\n    px = ToPrimitive(x, $Number);\n  }\n\n  var bothStrings = Type(px) === 'String' && Type(py) === 'String';\n\n  if (!bothStrings) {\n    var nx = ToNumber(px);\n    var ny = ToNumber(py);\n\n    if ($isNaN(nx) || $isNaN(ny)) {\n      return undefined;\n    }\n\n    if ($isFinite(nx) && $isFinite(ny) && nx === ny) {\n      return false;\n    }\n\n    if (nx === 0 && ny === 0) {\n      return false;\n    }\n\n    if (nx === Infinity) {\n      return false;\n    }\n\n    if (ny === Infinity) {\n      return true;\n    }\n\n    if (ny === -Infinity) {\n      return false;\n    }\n\n    if (nx === -Infinity) {\n      return true;\n    }\n\n    return nx < ny; // by now, these are both nonzero, finite, and not equal\n  }\n\n  if (isPrefixOf(py, px)) {\n    return false;\n  }\n\n  if (isPrefixOf(px, py)) {\n    return true;\n  }\n\n  return px < py; // both strings, neither a prefix of the other. shortcut for steps c-f\n};","map":null,"metadata":{},"sourceType":"module"}